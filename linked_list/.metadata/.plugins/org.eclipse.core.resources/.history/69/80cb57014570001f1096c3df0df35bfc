/*
 * linked_list.c
 *
 *  Created on: Aug 22, 2024
 *      Author: Giovanny
 */
#include <stdio.h>
#include <stdlib.h>
#include "platform_type.h"
#include "linked_list.h"

void LL_insert_at_begin(LL_t **Head,uint32 data)
{
	LL_t *temp_node=NULL;
	temp_node=(LL_t *)malloc(sizeof(LL_t));
	if (temp_node==NULL)
	{
		printf("No space to allocate a new element at the begin\n");
	}
	else
	{
		temp_node->LL_data=data;
		temp_node->LL_link=*Head;
		*Head=temp_node;
	}
}

void LL_insert_at_end(LL_t *Head,uint32 data)
{
	LL_t *temp_node=NULL;
	LL_t *Tail=Head;
	if (Head==NULL)
	{
		printf("the list is empty is has no end\n");
	}
	else
	{
		temp_node=(LL_t *)malloc(sizeof(LL_t));
		if (temp_node==NULL)
		{
			printf("No space to allocate a new element at the end\n");
		}
		else
		{
			temp_node->LL_data=data;
			temp_node->LL_link=NULL;
			while(Tail->LL_link != NULL)
			{
				Tail=Tail->LL_link;
			}
			Tail->LL_link=temp_node;
		}
	}
}

void LL_insert_after(LL_t *Head,uint32 data,uint32 position)
{
	LL_t *temp_node=NULL;
	LL_t *count_position=Head;
	uint32 counter=LL_data_number(Head);
	if(position>counter || position<=0)
	{
		printf("incorrect position \n");
	}
	else
	{
		temp_node=(LL_t *)malloc(sizeof(LL_t));
		if (temp_node==NULL)
		{
			printf("No space to allocate a new element after required position\n");
		}
		else
		{
			while (position > 1)
			{
				count_position=count_position->LL_link;
				position--;
			}
			temp_node->LL_data=data;
			temp_node->LL_link=count_position->LL_link;
			count_position->LL_link=temp_node;
		}
	}
}

void LL_delete_at_begin(LL_t **Head)
{
	LL_t *temp_node=NULL;
	if (*Head==NULL)
	{
		printf("the list is empty no item to delete\n");
	}
	else if( (*Head)->LL_link == NULL)
	{
		free(*Head);
		*Head=NULL;
	}
	else
	{
		temp_node=*Head;
		*Head = (temp_node)->LL_link;
		free(temp_node);
		temp_node=NULL;
	}
}

void LL_delete_at_end(LL_t **Head)
{
	LL_t *Before_Tail=*Head;
	LL_t *Tail=NULL;
	uint32 counter=LL_data_number(*Head);
	if (Head == NULL)
	{
		printf("the list is empty no item to delete\n");
	}
	else if (counter == 1)
	{
		free(*Head);
		*Head=NULL;
	}
	else
	{
		while(counter>2)
		{
			Before_Tail=Before_Tail->LL_link;
			counter--;
		}
		Tail=Before_Tail->LL_link;
		Before_Tail->LL_link=NULL;
		free(Tail);
		Tail=NULL;
	}
}

void LL_delete_after(LL_t **Head,uint32 position)
{
	LL_t *delete_node=NULL;
	LL_t *before_delete_node=*Head;
	uint32 counter=LL_data_number(*Head);
	if (Head == NULL)
	{
		printf("the list is empty no item to delete\n");
	}
	else if (position>counter || position<=0)
	{
		printf("incorrect position \n");
	}
	else if (counter==1)
	{
		free(*Head);
		*Head=NULL;
	}
	else
	{
		while (position>1)
		{
			before_delete_node=before_delete_node->LL_link;
			position--;
		}
		delete_node=before_delete_node->LL_link;
		before_delete_node->LL_link=delete_node->LL_link;
		free(delete_node);
		delete_node=NULL;
	}
}

void LL_middle_val(LL_t *Head)
{
	uint32 number=LL_data_number(Head);
	number=(number/2)+1;
	LL_t *temp=Head;
	while(number>1)
	{
		temp=temp->LL_link;
		number--;
	}
	printf("the middle val=%i\n",temp->LL_data);
}

void LL_display_data(LL_t *Head)
{
	LL_t *temp_node=Head;
	if (Head==NULL)
	{
		printf("the list is empty no data can be displayed\n");
	}
	else
	{
		while (temp_node->LL_link != NULL)
		{
			printf("-> %i ",temp_node->LL_data);
			temp_node=temp_node->LL_link;
		}
		printf("-> %i -> NULL\n",temp_node->LL_data);
	}
}

uint32 LL_data_number(LL_t *Head)
{
	uint32 number=1;
	LL_t *temp_node=Head;
	if (Head==NULL)
	{
			number=0;
	}
	else
	{
		while (temp_node->LL_link != NULL)
		{
			temp_node=temp_node->LL_link;
			number++;
		}
	}
	return number;
}
